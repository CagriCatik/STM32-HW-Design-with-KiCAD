"use strict";(self.webpackChunkPCB_Design=self.webpackChunkPCB_Design||[]).push([[3445],{366:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"Scripts/Netlist","title":"Netlist Manipulation","description":"Netlist manipulation is a powerful feature that allows designers to dynamically adjust, merge, and analyze the connectivity between components in a PCB design. Python scripting in KiCad enables more advanced control over the netlist, allowing you to optimize routing, improve signal integrity, and handle complex hierarchical designs.","source":"@site/docs/06_Scripts/04_Netlist.md","sourceDirName":"06_Scripts","slug":"/Scripts/Netlist","permalink":"/STM32-HW-Design-with-KiCAD/docs/Scripts/Netlist","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/06_Scripts/04_Netlist.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{},"sidebar":"ScriptSidebar","previous":{"title":"Design Rule Checking Customization","permalink":"/STM32-HW-Design-with-KiCAD/docs/Scripts/DRC"},"next":{"title":"Bill of Materials (BOM) Generation","permalink":"/STM32-HW-Design-with-KiCAD/docs/Scripts/BOM"}}');var s=t(4848),r=t(8453);const o={},a="Netlist Manipulation",l={},c=[{value:"Why Manipulate Netlists with Python?",id:"why-manipulate-netlists-with-python",level:2},{value:"Common Use Cases for Netlist Manipulation",id:"common-use-cases-for-netlist-manipulation",level:2},{value:"1. Merging Netlists in Hierarchical Designs",id:"1-merging-netlists-in-hierarchical-designs",level:3},{value:"2. Netlist Filtering and Analysis",id:"2-netlist-filtering-and-analysis",level:3},{value:"3. Reassigning Pins for Routing Optimization",id:"3-reassigning-pins-for-routing-optimization",level:3},{value:"4. Detecting Redundant Connections or Shorts",id:"4-detecting-redundant-connections-or-shorts",level:3},{value:"Step-by-Step Guide: Implementing Netlist Manipulation with Python",id:"step-by-step-guide-implementing-netlist-manipulation-with-python",level:2},{value:"Step 1: Load the Netlists",id:"step-1-load-the-netlists",level:3},{value:"Step 2: Merge the Netlists",id:"step-2-merge-the-netlists",level:3},{value:"Step 3: Analyze the Merged Netlist",id:"step-3-analyze-the-merged-netlist",level:3},{value:"Step 4: Reassign Pins for Optimization",id:"step-4-reassign-pins-for-optimization",level:3},{value:"Best Practices for Netlist Manipulation",id:"best-practices-for-netlist-manipulation",level:2},{value:"1. Preserve Hierarchy",id:"1-preserve-hierarchy",level:3},{value:"2. Backup the Original Netlist",id:"2-backup-the-original-netlist",level:3},{value:"3. Validation After Manipulation",id:"3-validation-after-manipulation",level:3},{value:"4. Modular Approach",id:"4-modular-approach",level:3},{value:"5. Maintain Consistent Net Names",id:"5-maintain-consistent-net-names",level:3},{value:"Advanced Example: Multi-Board System Netlist Merging",id:"advanced-example-multi-board-system-netlist-merging",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"netlist-manipulation",children:"Netlist Manipulation"})}),"\n",(0,s.jsx)(n.p,{children:"Netlist manipulation is a powerful feature that allows designers to dynamically adjust, merge, and analyze the connectivity between components in a PCB design. Python scripting in KiCad enables more advanced control over the netlist, allowing you to optimize routing, improve signal integrity, and handle complex hierarchical designs."}),"\n",(0,s.jsx)(n.p,{children:"Netlists are essentially the glue that connects all components in your design, describing which pins on each component should be connected to one another. By using Python scripts, designers can manipulate these connections, identify potential design issues, and automate tasks that would be tedious or error-prone if done manually."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"why-manipulate-netlists-with-python",children:"Why Manipulate Netlists with Python?"}),"\n",(0,s.jsx)(n.p,{children:"In complex designs, especially those with hierarchical structures or multi-board systems, manipulating the netlist directly can provide numerous advantages:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Merging Hierarchical Designs: When working with hierarchical designs, different subsystems may be designed separately. Python scripting can merge multiple netlists, ensuring that connections between different levels of hierarchy are maintained correctly."}),"\n",(0,s.jsx)(n.li,{children:"Optimizing Connectivity: Automated netlist manipulation allows you to reassign pins or modify connections to optimize routing strategies, reduce wire lengths, and improve overall board layout."}),"\n",(0,s.jsx)(n.li,{children:"Debugging and Analysis: Python can be used to analyze the netlist, detecting potential issues such as redundant connections, shorts, or open circuits. This can be particularly useful in large designs where manually identifying such problems is difficult."}),"\n",(0,s.jsx)(n.li,{children:"Version Control and Comparisons: Netlist manipulation scripts can be used to compare different versions of a design, ensuring that changes made between versions are intentional and not the result of errors or oversights."}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"common-use-cases-for-netlist-manipulation",children:"Common Use Cases for Netlist Manipulation"}),"\n",(0,s.jsx)(n.h3,{id:"1-merging-netlists-in-hierarchical-designs",children:"1. Merging Netlists in Hierarchical Designs"}),"\n",(0,s.jsx)(n.p,{children:"In large projects where different sections of a design are split into separate schematic sheets or developed by different teams, it may be necessary to combine multiple netlists into a single, cohesive netlist. Python scripts can automate this merging process, ensuring that all necessary connections between subsystems are maintained."}),"\n",(0,s.jsx)(n.p,{children:"Example Use Case:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A PCB design might have separate netlists for the power supply, the control circuitry, and the sensor interface. By merging these netlists, you ensure all connections between the subsystems are correct before proceeding to layout and routing."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-netlist-filtering-and-analysis",children:"2. Netlist Filtering and Analysis"}),"\n",(0,s.jsx)(n.p,{children:"In complex designs, it\u2019s often useful to filter the netlist to focus on specific sections of the design. For example, you may want to extract only the nets associated with power distribution, or isolate analog sections from digital ones for further analysis. Python scripts can quickly perform this filtering and allow for detailed analysis of specific parts of the design."}),"\n",(0,s.jsx)(n.p,{children:"Example Use Case:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A designer working on a mixed-signal PCB may need to separate the power nets from the signal nets for further analysis. The power nets can then be analyzed to ensure proper voltage distribution, while the signal nets can be inspected for any potential interference or routing issues."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"3-reassigning-pins-for-routing-optimization",children:"3. Reassigning Pins for Routing Optimization"}),"\n",(0,s.jsx)(n.p,{children:"During the routing phase of PCB design, you may discover that certain components could benefit from having their pins reassigned to different nets in order to simplify routing. Python scripts can automate the process of reassigning pins based on the current routing constraints, helping to reduce wire lengths and improve signal integrity."}),"\n",(0,s.jsx)(n.p,{children:"Example Use Case:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"In a design with multiple microcontroller GPIOs, a Python script can reassign GPIO pins dynamically to optimize trace lengths and minimize the number of crossing signals, improving the overall quality of the layout."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"4-detecting-redundant-connections-or-shorts",children:"4. Detecting Redundant Connections or Shorts"}),"\n",(0,s.jsx)(n.p,{children:"In complex designs, especially when multiple designers are involved, it\u2019s possible for redundant connections or shorts to occur. Python scripting can be used to analyze the netlist and detect these potential issues before they become costly errors during manufacturing."}),"\n",(0,s.jsx)(n.p,{children:"Example Use Case:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A netlist analysis script can check for nets that are connected to the same pin multiple times (redundant connections) or check for shorts between power and ground nets, providing an early warning to the designer."}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"step-by-step-guide-implementing-netlist-manipulation-with-python",children:"Step-by-Step Guide: Implementing Netlist Manipulation with Python"}),"\n",(0,s.jsx)(n.p,{children:"Let\u2019s explore an example where we merge multiple netlists and analyze the merged netlist for any connectivity issues. This example demonstrates how to load and manipulate netlists using Python in KiCad."}),"\n",(0,s.jsx)(n.h3,{id:"step-1-load-the-netlists",children:"Step 1: Load the Netlists"}),"\n",(0,s.jsxs)(n.p,{children:["To start manipulating netlists, you first need to load them into Python. This can be done using the ",(0,s.jsx)(n.code,{children:"pcbnew"})," library, which provides access to the PCB layout and its associated netlist."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import pcbnew\r\n\r\n# Load the first netlist\r\nnetlist1_path = "/path/to/netlist1.net"\r\nnetlist1 = pcbnew.LoadNetlist(netlist1_path)\r\n\r\n# Load the second netlist\r\nnetlist2_path = "/path/to/netlist2.net"\r\nnetlist2 = pcbnew.LoadNetlist(netlist2_path)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"step-2-merge-the-netlists",children:"Step 2: Merge the Netlists"}),"\n",(0,s.jsx)(n.p,{children:"Once the netlists are loaded, you can merge them into a single netlist. This is useful when combining designs from different subsystems or merging hierarchical blocks."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def merge_netlists(netlist1, netlist2):\r\n    # Loop through all components in the second netlist\r\n    for component in netlist2.GetComponents():\r\n        # Add component to the first netlist\r\n        netlist1.AddComponent(component)\r\n\r\n    # Loop through all nets in the second netlist\r\n    for net in netlist2.GetNets():\r\n        # Add nets to the first netlist\r\n        netlist1.AddNet(net)\r\n\r\n    print("Netlists merged successfully.")\r\n\r\n# Example usage\r\nmerge_netlists(netlist1, netlist2)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"step-3-analyze-the-merged-netlist",children:"Step 3: Analyze the Merged Netlist"}),"\n",(0,s.jsx)(n.p,{children:"After merging the netlists, it\u2019s important to analyze them to ensure that the merged design is correct. You can use Python to check for connectivity issues, such as shorts, open circuits, or redundant connections."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def analyze_netlist(netlist):\r\n    nets = netlist.GetNets()\r\n    \r\n    # Loop through each net and check for issues\r\n    for net in nets:\r\n        connections = net.GetConnections()\r\n\r\n        # Check for shorts (multiple nets connected to the same pin)\r\n        if len(set(connections)) != len(connections):\r\n            print(f"Short detected in net {net.GetName()}.")\r\n\r\n        # Check for open circuits (nets with too few connections)\r\n        if len(connections) < 2:\r\n            print(f"Open circuit detected in net {net.GetName()}.")\r\n\r\n    print("Netlist analysis complete.")\r\n\r\n# Example usage\r\nanalyze_netlist(netlist1)\n'})}),"\n",(0,s.jsx)(n.p,{children:"This simple analysis checks for shorts and open circuits in the merged netlist. If any issues are found, they are printed out, allowing the designer to address them before proceeding with the design."}),"\n",(0,s.jsx)(n.h3,{id:"step-4-reassign-pins-for-optimization",children:"Step 4: Reassign Pins for Optimization"}),"\n",(0,s.jsx)(n.p,{children:"In some cases, it may be beneficial to reassign component pins to optimize routing. Python allows you to do this programmatically, reducing the manual effort required to fine-tune the layout."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def reassign_pins(netlist, component_name, pin_assignments):\r\n    component = netlist.GetComponentByName(component_name)\r\n    \r\n    # Reassign pins based on the new pin assignments\r\n    for pin_number, new_net in pin_assignments.items():\r\n        pin = component.GetPinByNumber(pin_number)\r\n        pin.SetNet(new_net)\r\n    \r\n    print(f"Pins reassigned for component {component_name}.")\r\n\r\n# Example usage\r\npin_assignments = {\r\n    "1": "NET1",\r\n    "2": "NET2",\r\n    "3": "NET3"\r\n}\r\nreassign_pins(netlist1, "U1", pin_assignments)\n'})}),"\n",(0,s.jsx)(n.p,{children:"This example script allows you to specify a component and reassign its pins to different nets, optimizing the connectivity for easier routing."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-for-netlist-manipulation",children:"Best Practices for Netlist Manipulation"}),"\n",(0,s.jsx)(n.h3,{id:"1-preserve-hierarchy",children:"1. Preserve Hierarchy"}),"\n",(0,s.jsx)(n.p,{children:"When working with hierarchical designs, ensure that netlist manipulation scripts maintain the logical structure of the design. Flattening hierarchical designs can lead to confusion and increase the risk of connectivity errors."}),"\n",(0,s.jsx)(n.h3,{id:"2-backup-the-original-netlist",children:"2. Backup the Original Netlist"}),"\n",(0,s.jsx)(n.p,{children:"Before performing any manipulation, always back up the original netlist. This ensures that you can revert to the previous state if something goes wrong during the manipulation process."}),"\n",(0,s.jsx)(n.h3,{id:"3-validation-after-manipulation",children:"3. Validation After Manipulation"}),"\n",(0,s.jsx)(n.p,{children:"After modifying or merging netlists, it\u2019s essential to validate the netlist by running checks such as design rule checks (DRC), connectivity analysis, and schematic reviews. This ensures that the manipulated netlist adheres to the design\u2019s requirements."}),"\n",(0,s.jsx)(n.h3,{id:"4-modular-approach",children:"4. Modular Approach"}),"\n",(0,s.jsx)(n.p,{children:"If the netlist manipulation involves multiple steps (e.g., merging, pin reassignment, and optimization), it\u2019s best to modularize the script into separate functions. This not only makes the script more readable but also allows for easier debugging and reuse in future projects."}),"\n",(0,s.jsx)(n.h3,{id:"5-maintain-consistent-net-names",children:"5. Maintain Consistent Net Names"}),"\n",(0,s.jsx)(n.p,{children:"When manipulating netlists, ensure that consistent naming conventions are followed, especially when merging netlists from different sources. Inconsistent net names can cause confusion and lead to connectivity issues that are hard to trace."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"advanced-example-multi-board-system-netlist-merging",children:"Advanced Example: Multi-Board System Netlist Merging"}),"\n",(0,s.jsx)(n.p,{children:"In designs with multiple PCBs that need to communicate, merging netlists from different boards is essential to ensure proper interconnectivity. The following example demonstrates how to merge netlists from two different PCBs in a multi-board system and check for consistency between the interconnects."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def merge_multi_board_netlists(board1_netlist, board2_netlist, interconnects):\r\n    # Merge netlists as before\r\n    merge_netlists(board1_netlist, board2_netlist)\r\n    \r\n    # Check the interconnects for consistency\r\n    for interconnect in interconnects:\r\n        board1_net = board1_netlist.GetNetByName\r\n\r\n(interconnect['board1_net'])\r\n        board2_net = board2_netlist.GetNetByName(interconnect['board2_net'])\r\n\r\n        if board1_net != board2_net:\r\n            print(f\"Interconnect mismatch: {interconnect['board1_net']} on Board 1 does not match {interconnect['board2_net']} on Board 2.\")\r\n        else:\r\n            print(f\"Interconnect verified: {interconnect['board1_net']} matches {interconnect['board2_net']}.\")\r\n\r\n# Example usage\r\ninterconnects = [\r\n    {'board1_net': 'SPI_CLK', 'board2_net': 'SPI_CLK'},\r\n    {'board1_net': 'GND', 'board2_net': 'GND'}\r\n]\r\nmerge_multi_board_netlists(board1_netlist, board2_netlist, interconnects)\n"})}),"\n",(0,s.jsx)(n.p,{children:"This script merges the netlists for two different boards in a multi-board system and checks that interconnects (such as SPI and GND) match between the boards. Any discrepancies are flagged for review."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"Python scripting in KiCad provides immense flexibility for manipulating netlists, whether you're working with hierarchical designs, optimizing pin assignments, or ensuring connectivity across multi-board systems. By leveraging Python for netlist manipulation, PCB designers can automate complex tasks, improve design reliability, and streamline the development process. Whether merging designs, filtering nets for analysis, or optimizing component connections, Python offers powerful tools for improving your PCB design workflow."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(6540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);